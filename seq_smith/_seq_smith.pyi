# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import enum
import numpy
import numpy.typing
import typing

@typing.final
class AlignFrag:
    r"""
    Represents a single fragment within a sequence alignment.
    
    Args:
        frag_type (FragType): The type of the fragment (e.g., Match, AGap, BGap).
        sa_start (int): The starting position in sequence A.
        sb_start (int): The starting position in sequence B.
        len (int): The length of the fragment.
    """
    @property
    def frag_type(self) -> FragType: ...
    @frag_type.setter
    def frag_type(self, value: FragType) -> None: ...
    @property
    def sa_start(self) -> builtins.int: ...
    @property
    def sb_start(self) -> builtins.int: ...
    @property
    def len(self) -> builtins.int: ...

@typing.final
class Alignment:
    r"""
    Represents a complete sequence alignment.
    
    Args:
        align_frag (list[AlignFrag]): A list of alignment fragments.
        frag_count (int): The number of fragments in the alignment.
        score (int): The total score of the alignment.
    """
    @property
    def align_frag(self) -> builtins.list[AlignFrag]: ...
    @property
    def frag_count(self) -> builtins.int: ...
    @property
    def score(self) -> builtins.int: ...

@typing.final
class FragType(enum.Enum):
    r"""
    Represents the type of an alignment fragment.
    """
    AGap = ...
    BGap = ...
    Match = ...

def global_align(seqa: bytes, seqb: bytes, score_matrix: numpy.typing.NDArray[numpy.int32], gap_open: builtins.int, gap_extend: builtins.int) -> Alignment:
    r"""
    Performs a global alignment between two sequences using the Needleman-Wunsch algorithm.
    
    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (numpy.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.
    
    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.
    
    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """

def local_align(seqa: bytes, seqb: bytes, score_matrix: numpy.typing.NDArray[numpy.int32], gap_open: builtins.int, gap_extend: builtins.int) -> Alignment:
    r"""
    Performs a local alignment between two sequences using the Smith-Waterman algorithm.
    
    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (numpy.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.
    
    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.
    
    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """

def local_global_align(seqa: bytes, seqb: bytes, score_matrix: numpy.typing.NDArray[numpy.int32], gap_open: builtins.int, gap_extend: builtins.int) -> Alignment:
    r"""
    Performs a local-global alignment. This alignment finds the best local alignment of `seqa`
    within `seqb`, but `seqb` must be aligned globally.
    
    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (numpy.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.
    
    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.
    
    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """

def overlap_align(seqa: bytes, seqb: bytes, score_matrix: numpy.typing.NDArray[numpy.int32], gap_open: builtins.int, gap_extend: builtins.int) -> Alignment:
    r"""
    Performs an overlap alignment between two sequences.
    
    This alignment type does not penalize gaps at the start or end of either sequence,
    making it suitable for finding overlaps between sequences.
    
    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (numpy.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.
    
    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.
    
    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """


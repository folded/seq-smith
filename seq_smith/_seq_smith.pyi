# This file is automatically generated by pyo3_stub_gen

import enum
from collections.abc import Sequence
from typing import final

import np.typing as npt
import numpy as np

@final
class Alignment:
    r"""
    Represents a complete sequence alignment.

    Args:
        fragments (list[AlignmentFragment]): A list of alignment fragments.
        score (int): The total score of the alignment.
        stats (AlignmentStats): Statistics about the alignment.
    """
    @property
    def fragments(self) -> list[AlignmentFragment]: ...
    @property
    def score(self) -> int: ...
    @property
    def stats(self) -> AlignmentStats: ...

@final
class AlignmentFragment:
    r"""
    Represents a single fragment within a sequence alignment.

    Args:
        fragment_type (FragmentType): The type of the fragment (e.g., Match, AGap, BGap).
        sa_start (int): The starting position in sequence A.
        sb_start (int): The starting position in sequence B.
        len (int): The length of the fragment.
    """
    @property
    def fragment_type(self) -> FragmentType: ...
    @fragment_type.setter
    def fragment_type(self, value: FragmentType) -> None: ...
    @property
    def sa_start(self) -> int: ...
    @property
    def sb_start(self) -> int: ...
    @property
    def len(self) -> int: ...

@final
class AlignmentStats:
    r"""
    Represents detailed statistics about an alignment.
    """
    @property
    def num_exact_matches(self) -> int: ...
    @property
    def num_positive_mismatches(self) -> int: ...
    @property
    def num_negative_mismatches(self) -> int: ...
    @property
    def num_a_gaps(self) -> int: ...
    @property
    def num_b_gaps(self) -> int: ...
    @property
    def len(self) -> int: ...

@final
class FragmentType(enum.Enum):
    r"""
    Represents the type of an alignment fragment.
    """

    AGap = ...
    BGap = ...
    Match = ...

def global_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: np.typing.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment:
    r"""
    Performs a global alignment between two sequences using the Needleman-Wunsch algorithm.

    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (np.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.

    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.

    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """

def global_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]:
    r"""
    Performs global alignment of one sequence against many sequences in parallel.
    """

def local_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: np.typing.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment:
    r"""
    Performs a local alignment between two sequences using the Smith-Waterman algorithm.

    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (np.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.

    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.

    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """

def local_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]:
    r"""
    Performs local alignment of one sequence against many sequences in parallel.
    """

def local_global_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment:
    r"""
    Performs a local-global alignment. This alignment finds the best local alignment of `seqa`
    within `seqb`, but `seqb` must be aligned globally.

    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (np.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.

    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.

    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """

def local_global_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]:
    r"""
    Performs local-global alignment of one sequence against many sequences in parallel.
    """

def overlap_align(
    seqa: bytes,
    seqb: bytes,
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
) -> Alignment:
    r"""
    Performs an overlap alignment between two sequences.

    This alignment type does not penalize gaps at the start or end of either sequence,
    making it suitable for finding overlaps between sequences.

    Args:
        seqa (bytes): The first sequence as a byte array.
        seqb (bytes): The second sequence as a byte array.
        score_matrix (np.ndarray): A 2D numpy array representing the scoring matrix.
        gap_open (int): The penalty for opening a gap. Must be negative.
        gap_extend (int): The penalty for extending a gap. Must be negative.

    Raises:
        ValueError: If any of the following are true:
            * input sequences are empty
            * gap penalties are not negative.
            * score matrix is not 2-dimensional and square.

    Returns:
        Alignment: An Alignment object containing the score and alignment fragments.
    """

def overlap_align_many(
    seqa: bytes,
    seqbs: Sequence[bytes],
    score_matrix: npt.NDArray[np.int32],
    gap_open: int,
    gap_extend: int,
    num_threads: int | None = None,
) -> list[Alignment]:
    r"""
    Performs overlap alignment of one sequence against many sequences in parallel.
    """
